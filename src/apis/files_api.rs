/*
 * VRChat API Documentation
 *
 *
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_file_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFileVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFileError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_file_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFileVersionError {
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_file_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadFileVersionError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`finish_file_data_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FinishFileDataUploadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_admin_asset_bundle`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAdminAssetBundleError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_analysis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileAnalysisError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_analysis_security`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileAnalysisSecurityError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_analysis_standard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileAnalysisStandardError {
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_data_upload_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileDataUploadStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFilesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_file_data_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartFileDataUploadError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_gallery_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadGalleryImageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_icon`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadIconError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadImageError {
    UnknownValue(serde_json::Value),
}

/// Creates a new File object
pub async fn create_file(
    configuration: &configuration::Configuration,
    create_file_request: Option<models::CreateFileRequest>,
) -> Result<models::File, Error<CreateFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_file_request = create_file_request;

    let uri_str = format!("{}/file", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_file_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
pub async fn create_file_version(
    configuration: &configuration::Configuration,
    file_id: &str,
    create_file_version_request: Option<models::CreateFileVersionRequest>,
) -> Result<models::File, Error<CreateFileVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_body_create_file_version_request = create_file_version_request;

    let uri_str = format!(
        "{}/file/{fileId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_file_version_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFileVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a File object.
pub async fn delete_file(
    configuration: &configuration::Configuration,
    file_id: &str,
) -> Result<models::File, Error<DeleteFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;

    let uri_str = format!(
        "{}/file/{fileId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a specific version of a file. You can only delete the latest version.
pub async fn delete_file_version(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
) -> Result<models::File, Error<DeleteFileVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;

    let uri_str = format!(
        "{}/file/{fileId}/{versionId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFileVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
pub async fn download_file_version(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
) -> Result<reqwest::Response, Error<DownloadFileVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;

    let uri_str = format!(
        "{}/file/{fileId}/{versionId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadFileVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
pub async fn finish_file_data_upload(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
    file_type: &str,
    finish_file_data_upload_request: Option<models::FinishFileDataUploadRequest>,
) -> Result<models::File, Error<FinishFileDataUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;
    let p_path_file_type = file_type;
    let p_body_finish_file_data_upload_request = finish_file_data_upload_request;

    let uri_str = format!(
        "{}/file/{fileId}/{versionId}/{fileType}/finish",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id,
        fileType = crate::apis::urlencode(p_path_file_type)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_finish_file_data_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FinishFileDataUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns an AdminAssetBundle
pub async fn get_admin_asset_bundle(
    configuration: &configuration::Configuration,
    admin_asset_bundle_id: &str,
) -> Result<models::AdminAssetBundle, Error<GetAdminAssetBundleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_admin_asset_bundle_id = admin_asset_bundle_id;

    let uri_str = format!(
        "{}/adminassetbundles/{adminAssetBundleId}",
        configuration.base_path,
        adminAssetBundleId = crate::apis::urlencode(p_path_admin_asset_bundle_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AdminAssetBundle`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AdminAssetBundle`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAdminAssetBundleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Shows general information about the \"File\" object. Each File can have several \"Version\"'s, and each Version can have multiple real files or \"Data\" blobs.
pub async fn get_file(
    configuration: &configuration::Configuration,
    file_id: &str,
) -> Result<models::File, Error<GetFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;

    let uri_str = format!(
        "{}/file/{fileId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the performance analysis for the uploaded assets of an avatar
pub async fn get_file_analysis(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
) -> Result<models::FileAnalysis, Error<GetFileAnalysisError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;

    let uri_str = format!(
        "{}/analysis/{fileId}/{versionId}",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileAnalysis`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileAnalysis`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileAnalysisError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the security performance analysis for the uploaded assets of an avatar
pub async fn get_file_analysis_security(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
) -> Result<models::FileAnalysis, Error<GetFileAnalysisSecurityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;

    let uri_str = format!(
        "{}/analysis/{fileId}/{versionId}/security",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileAnalysis`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileAnalysis`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileAnalysisSecurityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the standard performance analysis for the uploaded assets of an avatar
pub async fn get_file_analysis_standard(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
) -> Result<models::FileAnalysis, Error<GetFileAnalysisStandardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;

    let uri_str = format!(
        "{}/analysis/{fileId}/{versionId}/standard",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileAnalysis`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileAnalysis`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileAnalysisStandardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
pub async fn get_file_data_upload_status(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
    file_type: &str,
) -> Result<models::FileVersionUploadStatus, Error<GetFileDataUploadStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;
    let p_path_file_type = file_type;

    let uri_str = format!(
        "{}/file/{fileId}/{versionId}/{fileType}/status",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id,
        fileType = crate::apis::urlencode(p_path_file_type)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileVersionUploadStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileVersionUploadStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileDataUploadStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of files
pub async fn get_files(
    configuration: &configuration::Configuration,
    tag: Option<&str>,
    user_id: Option<&str>,
    n: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::File>, Error<GetFilesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_tag = tag;
    let p_query_user_id = user_id;
    let p_query_n = n;
    let p_query_offset = offset;

    let uri_str = format!("{}/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::File&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::File&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
pub async fn start_file_data_upload(
    configuration: &configuration::Configuration,
    file_id: &str,
    version_id: i32,
    file_type: &str,
    part_number: Option<i32>,
) -> Result<models::FileUploadUrl, Error<StartFileDataUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;
    let p_path_version_id = version_id;
    let p_path_file_type = file_type;
    let p_query_part_number = part_number;

    let uri_str = format!(
        "{}/file/{fileId}/{versionId}/{fileType}/start",
        configuration.base_path,
        fileId = crate::apis::urlencode(p_path_file_id),
        versionId = p_path_version_id,
        fileType = crate::apis::urlencode(p_path_file_type)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_part_number {
        req_builder = req_builder.query(&[("partNumber", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileUploadUrl`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileUploadUrl`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartFileDataUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload a gallery image
pub async fn upload_gallery_image(
    configuration: &configuration::Configuration,
    file: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
) -> Result<models::File, Error<UploadGalleryImageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_file = file;

    let uri_str = format!("{}/gallery", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_file)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("file", part);
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadGalleryImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload an icon
pub async fn upload_icon(
    configuration: &configuration::Configuration,
    file: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
) -> Result<models::File, Error<UploadIconError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_file = file;

    let uri_str = format!("{}/icon", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_file)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("file", part);
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadIconError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Upload an image, which can be an icon, gallery image, sticker or emoji
pub async fn upload_image(
    configuration: &configuration::Configuration,
    file: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
    tag: &str,
    frames: Option<i32>,
    frames_over_time: Option<i32>,
    animation_style: Option<&str>,
    mask_tag: Option<&str>,
) -> Result<models::File, Error<UploadImageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_file = file;
    let p_form_tag = tag;
    let p_form_frames = frames;
    let p_form_frames_over_time = frames_over_time;
    let p_form_animation_style = animation_style;
    let p_form_mask_tag = mask_tag;

    let uri_str = format!("{}/file/image", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_file)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("file", part);
    multipart_form = multipart_form.text("tag", p_form_tag.to_string());
    if let Some(param_value) = p_form_frames {
        multipart_form = multipart_form.text("frames", param_value.to_string());
    }
    if let Some(param_value) = p_form_frames_over_time {
        multipart_form = multipart_form.text("framesOverTime", param_value.to_string());
    }
    if let Some(param_value) = p_form_animation_style {
        multipart_form = multipart_form.text("animationStyle", param_value.to_string());
    }
    if let Some(param_value) = p_form_mask_tag {
        multipart_form = multipart_form.text("maskTag", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::File`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::File`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
