/*
 * VRChat API Documentation
 *
 *
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`add_group_gallery_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddGroupGalleryImageError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_group_member_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddGroupMemberRoleError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddGroupPostError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ban_group_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BanGroupMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_group_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelGroupRequestError {
    Status400(),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_announcement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupAnnouncementError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_gallery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupGalleryError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupInviteError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupRoleError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_announcement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupAnnouncementError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_gallery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupGalleryError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_gallery_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupGalleryImageError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupInviteError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupPostError {
    Status401(models::Error),
    Status404(models::Success),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_group_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGroupRoleError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_announcements`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupAnnouncementsError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_audit_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupAuditLogsError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_bans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupBansError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_gallery_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupGalleryImagesError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_instances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupInstancesError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_invites`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupInvitesError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMemberError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupMembersError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_permissions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupPermissionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_posts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupPostsError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_requests`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupRequestsError {
    Status400(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_role_templates`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupRoleTemplatesError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupRolesError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`join_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JoinGroupError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`kick_group_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KickGroupMemberError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveGroupError {
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_group_member_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGroupMemberRoleError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`respond_group_join_request`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RespondGroupJoinRequestError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGroupsError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unban_group_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnbanGroupMemberError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_gallery`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupGalleryError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupMemberError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupPostError {
    Status401(models::Error),
    Status404(models::Success),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_representation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupRepresentationError {
    Status401(models::Error),
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupRoleError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// Adds an image to a Group gallery.
pub async fn add_group_gallery_image(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_gallery_id: &str,
    add_group_gallery_image_request: models::AddGroupGalleryImageRequest,
) -> Result<models::GroupGalleryImage, Error<AddGroupGalleryImageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_gallery_id = group_gallery_id;
    let p_body_add_group_gallery_image_request = add_group_gallery_image_request;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries/{groupGalleryId}/images",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupGalleryId = crate::apis::urlencode(p_path_group_gallery_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_add_group_gallery_image_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGalleryImage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGalleryImage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddGroupGalleryImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Adds a Role to a Group Member
pub async fn add_group_member_role(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
    group_role_id: &str,
) -> Result<Vec<String>, Error<AddGroupMemberRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;
    let p_path_group_role_id = group_role_id;

    let uri_str = format!(
        "{}/groups/{groupId}/members/{userId}/roles/{groupRoleId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id),
        groupRoleId = crate::apis::urlencode(p_path_group_role_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddGroupMemberRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a post in a Group.
pub async fn add_group_post(
    configuration: &configuration::Configuration,
    group_id: &str,
    create_group_post_request: models::CreateGroupPostRequest,
) -> Result<models::GroupPost, Error<AddGroupPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_create_group_post_request = create_group_post_request;

    let uri_str = format!(
        "{}/groups/{groupId}/posts",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPost`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPost`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddGroupPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Bans a user from a Group.
pub async fn ban_group_member(
    configuration: &configuration::Configuration,
    group_id: &str,
    ban_group_member_request: models::BanGroupMemberRequest,
) -> Result<models::GroupMember, Error<BanGroupMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_ban_group_member_request = ban_group_member_request;

    let uri_str = format!(
        "{}/groups/{groupId}/bans",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_ban_group_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BanGroupMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cancels a request sent to join the group.
pub async fn cancel_group_request(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<(), Error<CancelGroupRequestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/requests",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelGroupRequestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
pub async fn create_group(
    configuration: &configuration::Configuration,
    create_group_request: models::CreateGroupRequest,
) -> Result<models::Group, Error<CreateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_group_request = create_group_request;

    let uri_str = format!("{}/groups", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
pub async fn create_group_announcement(
    configuration: &configuration::Configuration,
    group_id: &str,
    create_group_announcement_request: models::CreateGroupAnnouncementRequest,
) -> Result<models::GroupAnnouncement, Error<CreateGroupAnnouncementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_create_group_announcement_request = create_group_announcement_request;

    let uri_str = format!(
        "{}/groups/{groupId}/announcement",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupAnnouncement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupAnnouncement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupAnnouncementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a gallery for a Group.
pub async fn create_group_gallery(
    configuration: &configuration::Configuration,
    group_id: &str,
    create_group_gallery_request: models::CreateGroupGalleryRequest,
) -> Result<models::GroupGallery, Error<CreateGroupGalleryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_create_group_gallery_request = create_group_gallery_request;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_gallery_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGallery`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGallery`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupGalleryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends an invite to a user to join the group.
pub async fn create_group_invite(
    configuration: &configuration::Configuration,
    group_id: &str,
    create_group_invite_request: models::CreateGroupInviteRequest,
) -> Result<(), Error<CreateGroupInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_create_group_invite_request = create_group_invite_request;

    let uri_str = format!(
        "{}/groups/{groupId}/invites",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_invite_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a Group role.
pub async fn create_group_role(
    configuration: &configuration::Configuration,
    group_id: &str,
    create_group_role_request: models::CreateGroupRoleRequest,
) -> Result<models::GroupRole, Error<CreateGroupRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_create_group_role_request = create_group_role_request;

    let uri_str = format!(
        "{}/groups/{groupId}/roles",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupRole`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupRole`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a Group.
pub async fn delete_group(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<models::Success, Error<DeleteGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes the announcement for a Group.
pub async fn delete_group_announcement(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<models::Success, Error<DeleteGroupAnnouncementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/announcement",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupAnnouncementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a gallery for a Group.
pub async fn delete_group_gallery(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_gallery_id: &str,
) -> Result<models::Success, Error<DeleteGroupGalleryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_gallery_id = group_gallery_id;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries/{groupGalleryId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupGalleryId = crate::apis::urlencode(p_path_group_gallery_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupGalleryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes an image from a Group gallery.
pub async fn delete_group_gallery_image(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_gallery_id: &str,
    group_gallery_image_id: &str,
) -> Result<models::Success, Error<DeleteGroupGalleryImageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_gallery_id = group_gallery_id;
    let p_path_group_gallery_image_id = group_gallery_image_id;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupGalleryId = crate::apis::urlencode(p_path_group_gallery_id),
        groupGalleryImageId = crate::apis::urlencode(p_path_group_gallery_image_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupGalleryImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes an Group invite sent to a User
pub async fn delete_group_invite(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
) -> Result<(), Error<DeleteGroupInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/groups/{groupId}/invites/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a Group post
pub async fn delete_group_post(
    configuration: &configuration::Configuration,
    group_id: &str,
    notification_id: &str,
) -> Result<models::Success, Error<DeleteGroupPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_notification_id = notification_id;

    let uri_str = format!(
        "{}/groups/{groupId}/posts/{notificationId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        notificationId = crate::apis::urlencode(p_path_notification_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a Group Role by ID and returns the remaining roles.
pub async fn delete_group_role(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_role_id: &str,
) -> Result<Vec<models::GroupRole>, Error<DeleteGroupRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_role_id = group_role_id;

    let uri_str = format!(
        "{}/groups/{groupId}/roles/{groupRoleId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupRoleId = crate::apis::urlencode(p_path_group_role_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGroupRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a single Group by ID.
pub async fn get_group(
    configuration: &configuration::Configuration,
    group_id: &str,
    include_roles: Option<bool>,
) -> Result<models::Group, Error<GetGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_include_roles = include_roles;

    let uri_str = format!(
        "{}/groups/{groupId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_roles {
        req_builder = req_builder.query(&[("includeRoles", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**. If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
pub async fn get_group_announcements(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<models::GroupAnnouncement, Error<GetGroupAnnouncementsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/announcement",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupAnnouncement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupAnnouncement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupAnnouncementsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of audit logs for a Group.
pub async fn get_group_audit_logs(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
    start_date: Option<String>,
    end_date: Option<String>,
    actor_ids: Option<&str>,
    event_types: Option<&str>,
    target_ids: Option<&str>,
) -> Result<models::PaginatedGroupAuditLogEntryList, Error<GetGroupAuditLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;
    let p_query_start_date = start_date;
    let p_query_end_date = end_date;
    let p_query_actor_ids = actor_ids;
    let p_query_event_types = event_types;
    let p_query_target_ids = target_ids;

    let uri_str = format!(
        "{}/groups/{groupId}/auditLogs",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_actor_ids {
        req_builder = req_builder.query(&[("actorIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event_types {
        req_builder = req_builder.query(&[("eventTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_target_ids {
        req_builder = req_builder.query(&[("targetIds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupAuditLogEntryList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupAuditLogEntryList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupAuditLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of banned users for a Group.
pub async fn get_group_bans(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::GroupMember>, Error<GetGroupBansError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/groups/{groupId}/bans",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupBansError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of images for a Group gallery.
pub async fn get_group_gallery_images(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_gallery_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
    approved: Option<bool>,
) -> Result<Vec<models::GroupGalleryImage>, Error<GetGroupGalleryImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_gallery_id = group_gallery_id;
    let p_query_n = n;
    let p_query_offset = offset;
    let p_query_approved = approved;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries/{groupGalleryId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupGalleryId = crate::apis::urlencode(p_path_group_gallery_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_approved {
        req_builder = req_builder.query(&[("approved", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupGalleryImage&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupGalleryImage&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupGalleryImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of group instances
pub async fn get_group_instances(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<Vec<models::GroupInstance>, Error<GetGroupInstancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/instances",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupInstance&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupInstance&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupInstancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of members that have been invited to the Group.
pub async fn get_group_invites(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::GroupMember>, Error<GetGroupInvitesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/groups/{groupId}/invites",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupInvitesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a LimitedGroup Member.
pub async fn get_group_member(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
) -> Result<models::GroupLimitedMember, Error<GetGroupMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/groups/{groupId}/members/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupLimitedMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupLimitedMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
pub async fn get_group_members(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
    sort: Option<models::GroupSearchSort>,
    role_id: Option<&str>,
) -> Result<Vec<models::GroupMember>, Error<GetGroupMembersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;
    let p_query_sort = sort;
    let p_query_role_id = role_id;

    let uri_str = format!(
        "{}/groups/{groupId}/members",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_role_id {
        req_builder = req_builder.query(&[("roleId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupMembersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a List of all possible/available permissions for a Group.
pub async fn get_group_permissions(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<Vec<models::GroupPermission>, Error<GetGroupPermissionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/permissions",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupPermission&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupPermission&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupPermissionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get posts from a Group
pub async fn get_group_posts(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
    public_only: Option<bool>,
) -> Result<models::GetGroupPosts200Response, Error<GetGroupPostsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;
    let p_query_public_only = public_only;

    let uri_str = format!(
        "{}/groups/{groupId}/posts",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_only {
        req_builder = req_builder.query(&[("publicOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGroupPosts200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGroupPosts200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupPostsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of members that have requested to join the Group.
pub async fn get_group_requests(
    configuration: &configuration::Configuration,
    group_id: &str,
    n: Option<i32>,
    offset: Option<i32>,
    blocked: Option<bool>,
) -> Result<Vec<models::GroupMember>, Error<GetGroupRequestsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_query_n = n;
    let p_query_offset = offset;
    let p_query_blocked = blocked;

    let uri_str = format!(
        "{}/groups/{groupId}/requests",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_blocked {
        req_builder = req_builder.query(&[("blocked", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupMember&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupRequestsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Obtain predefined templates for group roles
pub async fn get_group_role_templates(
    configuration: &configuration::Configuration,
) -> Result<
    std::collections::HashMap<String, models::GroupRoleTemplateValues>,
    Error<GetGroupRoleTemplatesError>,
> {
    let uri_str = format!("{}/groups/roleTemplates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GroupRoleTemplateValues&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::GroupRoleTemplateValues&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupRoleTemplatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a Group Role by ID.
pub async fn get_group_roles(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<Vec<models::GroupRole>, Error<GetGroupRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/roles",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Join a Group by ID and returns the member object.
pub async fn join_group(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<models::GroupMember, Error<JoinGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/join",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<JoinGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
pub async fn kick_group_member(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
) -> Result<(), Error<KickGroupMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/groups/{groupId}/members/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<KickGroupMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Leave a group by ID.
pub async fn leave_group(
    configuration: &configuration::Configuration,
    group_id: &str,
) -> Result<(), Error<LeaveGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;

    let uri_str = format!(
        "{}/groups/{groupId}/leave",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaveGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes a Role from a Group Member
pub async fn remove_group_member_role(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
    group_role_id: &str,
) -> Result<Vec<String>, Error<RemoveGroupMemberRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;
    let p_path_group_role_id = group_role_id;

    let uri_str = format!(
        "{}/groups/{groupId}/members/{userId}/roles/{groupRoleId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id),
        groupRoleId = crate::apis::urlencode(p_path_group_role_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGroupMemberRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Responds to a Group Join Request with Accept/Deny
pub async fn respond_group_join_request(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
    respond_group_join_request: models::RespondGroupJoinRequest,
) -> Result<(), Error<RespondGroupJoinRequestError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;
    let p_body_respond_group_join_request = respond_group_join_request;

    let uri_str = format!(
        "{}/groups/{groupId}/requests/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_respond_group_join_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RespondGroupJoinRequestError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Searches Groups by name or shortCode
pub async fn search_groups(
    configuration: &configuration::Configuration,
    query: Option<&str>,
    offset: Option<i32>,
    n: Option<i32>,
) -> Result<Vec<models::LimitedGroup>, Error<SearchGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_query = query;
    let p_query_offset = offset;
    let p_query_n = n;

    let uri_str = format!("{}/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LimitedGroup&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LimitedGroup&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unbans a user from a Group.
pub async fn unban_group_member(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
) -> Result<models::GroupMember, Error<UnbanGroupMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/groups/{groupId}/bans/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnbanGroupMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a Group and returns it.
pub async fn update_group(
    configuration: &configuration::Configuration,
    group_id: &str,
    update_group_request: Option<models::UpdateGroupRequest>,
) -> Result<models::Group, Error<UpdateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_update_group_request = update_group_request;

    let uri_str = format!(
        "{}/groups/{groupId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a gallery for a Group.
pub async fn update_group_gallery(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_gallery_id: &str,
    update_group_gallery_request: Option<models::UpdateGroupGalleryRequest>,
) -> Result<models::GroupGallery, Error<UpdateGroupGalleryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_gallery_id = group_gallery_id;
    let p_body_update_group_gallery_request = update_group_gallery_request;

    let uri_str = format!(
        "{}/groups/{groupId}/galleries/{groupGalleryId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupGalleryId = crate::apis::urlencode(p_path_group_gallery_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_group_gallery_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupGallery`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupGallery`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupGalleryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a Group Member
pub async fn update_group_member(
    configuration: &configuration::Configuration,
    group_id: &str,
    user_id: &str,
    update_group_member_request: Option<models::UpdateGroupMemberRequest>,
) -> Result<models::GroupLimitedMember, Error<UpdateGroupMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_user_id = user_id;
    let p_body_update_group_member_request = update_group_member_request;

    let uri_str = format!(
        "{}/groups/{groupId}/members/{userId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_group_member_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupLimitedMember`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupLimitedMember`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Edits a Group post
pub async fn update_group_post(
    configuration: &configuration::Configuration,
    group_id: &str,
    notification_id: &str,
    create_group_post_request: models::CreateGroupPostRequest,
) -> Result<models::GroupPost, Error<UpdateGroupPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_notification_id = notification_id;
    let p_body_create_group_post_request = create_group_post_request;

    let uri_str = format!(
        "{}/groups/{groupId}/posts/{notificationId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        notificationId = crate::apis::urlencode(p_path_notification_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_group_post_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPost`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPost`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates whether the user is representing the group.  When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
pub async fn update_group_representation(
    configuration: &configuration::Configuration,
    group_id: &str,
    update_group_representation_request: models::UpdateGroupRepresentationRequest,
) -> Result<models::Success, Error<UpdateGroupRepresentationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_body_update_group_representation_request = update_group_representation_request;

    let uri_str = format!(
        "{}/groups/{groupId}/representation",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_group_representation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Success`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Success`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupRepresentationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a group role by ID.
pub async fn update_group_role(
    configuration: &configuration::Configuration,
    group_id: &str,
    group_role_id: &str,
    update_group_role_request: Option<models::UpdateGroupRoleRequest>,
) -> Result<Vec<models::GroupRole>, Error<UpdateGroupRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_id = group_id;
    let p_path_group_role_id = group_role_id;
    let p_body_update_group_role_request = update_group_role_request;

    let uri_str = format!(
        "{}/groups/{groupId}/roles/{groupRoleId}",
        configuration.base_path,
        groupId = crate::apis::urlencode(p_path_group_id),
        groupRoleId = crate::apis::urlencode(p_path_group_role_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_group_role_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GroupRole&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
