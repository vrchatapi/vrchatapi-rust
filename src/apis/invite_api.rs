/*
 * VRChat API Documentation
 *
 *
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`get_invite_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInviteMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_invite_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInviteMessagesError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invite_myself_to`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteMyselfToError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invite_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteUserError {
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invite_user_with_photo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteUserWithPhotoError {
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestInviteError {
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`request_invite_with_photo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RequestInviteWithPhotoError {
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_invite_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetInviteMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status404(models::Error),
    Status429(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`respond_invite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RespondInviteError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`respond_invite_with_photo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RespondInviteWithPhotoError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_invite_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInviteMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status429(models::Error),
    UnknownValue(serde_json::Value),
}

/// Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
pub async fn get_invite_message(
    configuration: &configuration::Configuration,
    user_id: &str,
    message_type: models::InviteMessageType,
    slot: i32,
) -> Result<models::InviteMessage, Error<GetInviteMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_message_type = message_type;
    let p_path_slot = slot;

    let uri_str = format!(
        "{}/message/{userId}/{messageType}/{slot}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id),
        messageType = p_path_message_type.to_string(),
        slot = p_path_slot
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InviteMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InviteMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInviteMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
pub async fn get_invite_messages(
    configuration: &configuration::Configuration,
    user_id: &str,
    message_type: models::InviteMessageType,
) -> Result<Vec<models::InviteMessage>, Error<GetInviteMessagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_message_type = message_type;

    let uri_str = format!(
        "{}/message/{userId}/{messageType}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id),
        messageType = p_path_message_type.to_string()
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInviteMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends self an invite to an instance
pub async fn invite_myself_to(
    configuration: &configuration::Configuration,
    world_id: &str,
    instance_id: &str,
) -> Result<models::SentNotification, Error<InviteMyselfToError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_world_id = world_id;
    let p_path_instance_id = instance_id;

    let uri_str = format!(
        "{}/invite/myself/to/{worldId}:{instanceId}",
        configuration.base_path,
        worldId = crate::apis::urlencode(p_path_world_id),
        instanceId = crate::apis::urlencode(p_path_instance_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SentNotification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SentNotification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InviteMyselfToError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends an invite to a user. Returns the Notification of type `invite` that was sent.
pub async fn invite_user(
    configuration: &configuration::Configuration,
    user_id: &str,
    invite_request: models::InviteRequest,
) -> Result<models::SentNotification, Error<InviteUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_body_invite_request = invite_request;

    let uri_str = format!(
        "{}/invite/{userId}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_invite_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SentNotification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SentNotification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InviteUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
pub async fn invite_user_with_photo(
    configuration: &configuration::Configuration,
    user_id: &str,
    image: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
    data: models::InviteRequest,
) -> Result<models::SentNotification, Error<InviteUserWithPhotoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_form_image = image;
    let p_form_data = data;

    let uri_str = format!(
        "{}/invite/{userId}/photo",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_image)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("image", part);
    multipart_form = multipart_form.text("data", serde_json::to_string_pretty(&p_form_data)?);
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SentNotification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SentNotification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InviteUserWithPhotoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
pub async fn request_invite(
    configuration: &configuration::Configuration,
    user_id: &str,
    request_invite_request: Option<models::RequestInviteRequest>,
) -> Result<models::Notification, Error<RequestInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_body_request_invite_request = request_invite_request;

    let uri_str = format!(
        "{}/requestInvite/{userId}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request_invite_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Notification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Notification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
pub async fn request_invite_with_photo(
    configuration: &configuration::Configuration,
    user_id: &str,
    image: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
    data: models::RequestInviteRequest,
) -> Result<models::Notification, Error<RequestInviteWithPhotoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_form_image = image;
    let p_form_data = data;

    let uri_str = format!(
        "{}/requestInvite/{userId}/photo",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_image)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("image", part);
    multipart_form = multipart_form.text("data", serde_json::to_string_pretty(&p_form_data)?);
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Notification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Notification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RequestInviteWithPhotoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
pub async fn reset_invite_message(
    configuration: &configuration::Configuration,
    user_id: &str,
    message_type: models::InviteMessageType,
    slot: i32,
) -> Result<Vec<models::InviteMessage>, Error<ResetInviteMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_message_type = message_type;
    let p_path_slot = slot;

    let uri_str = format!(
        "{}/message/{userId}/{messageType}/{slot}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id),
        messageType = p_path_message_type.to_string(),
        slot = p_path_slot
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetInviteMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
pub async fn respond_invite(
    configuration: &configuration::Configuration,
    notification_id: &str,
    invite_response: models::InviteResponse,
) -> Result<models::Notification, Error<RespondInviteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_notification_id = notification_id;
    let p_body_invite_response = invite_response;

    let uri_str = format!(
        "{}/invite/{notificationId}/response",
        configuration.base_path,
        notificationId = crate::apis::urlencode(p_path_notification_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_invite_response);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Notification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Notification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RespondInviteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.  In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection. In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.'
pub async fn respond_invite_with_photo(
    configuration: &configuration::Configuration,
    notification_id: &str,
    image: impl Into<::std::borrow::Cow<'static, [u8]>>,
    filename: impl Into<::std::borrow::Cow<'static, str>>,
    mime_type: &str,
    data: models::InviteResponse,
) -> Result<models::Notification, Error<RespondInviteWithPhotoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_notification_id = notification_id;
    let p_form_image = image;
    let p_form_data = data;

    let uri_str = format!(
        "{}/invite/{notificationId}/response/photo",
        configuration.base_path,
        notificationId = crate::apis::urlencode(p_path_notification_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    let part = reqwest::multipart::Part::bytes(p_form_image)
        .file_name(filename)
        .mime_str(mime_type)?;
    multipart_form = multipart_form.part("image", part);
    multipart_form = multipart_form.text("data", serde_json::to_string_pretty(&p_form_data)?);
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Notification`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Notification`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RespondInviteWithPhotoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
pub async fn update_invite_message(
    configuration: &configuration::Configuration,
    user_id: &str,
    message_type: models::InviteMessageType,
    slot: i32,
    update_invite_message_request: Option<models::UpdateInviteMessageRequest>,
) -> Result<Vec<models::InviteMessage>, Error<UpdateInviteMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_path_message_type = message_type;
    let p_path_slot = slot;
    let p_body_update_invite_message_request = update_invite_message_request;

    let uri_str = format!(
        "{}/message/{userId}/{messageType}/{slot}",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id),
        messageType = p_path_message_type.to_string(),
        slot = p_path_slot
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_invite_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::InviteMessage&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateInviteMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
