/*
 * VRChat API Documentation
 *
 *
 * Contact: vrchatapi.lpv0t@aries.fyi
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAvatarError {
    Status400(models::Error),
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAvatarError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_impostor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteImpostorError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enqueue_impostor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnqueueImpostorError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAvatarError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_avatar_styles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAvatarStylesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_favorited_avatars`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFavoritedAvatarsError {
    Status401(models::Error),
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_impostor_queue_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImpostorQueueStatsError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_licensed_avatars`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLicensedAvatarsError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_own_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOwnAvatarError {
    Status401(models::Error),
    Status403(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_avatars`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchAvatarsError {
    Status401(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`select_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelectAvatarError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`select_fallback_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SelectFallbackAvatarError {
    Status401(models::Error),
    Status403(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_avatar`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAvatarError {
    Status401(models::Error),
    Status404(models::Error),
    UnknownValue(serde_json::Value),
}

/// Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
pub async fn create_avatar(
    configuration: &configuration::Configuration,
    create_avatar_request: Option<models::CreateAvatarRequest>,
) -> Result<models::Avatar, Error<CreateAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_avatar_request = create_avatar_request;

    let uri_str = format!("{}/avatars", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_avatar_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Avatar`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Avatar`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
pub async fn delete_avatar(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<models::Avatar, Error<DeleteAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Avatar`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Avatar`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete generated Impostor for that avatar.
pub async fn delete_impostor(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<(), Error<DeleteImpostorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}/impostor",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteImpostorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Enqueue Impostor generation for that avatar.
pub async fn enqueue_impostor(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<models::ServiceStatus, Error<EnqueueImpostorError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}/impostor/enqueue",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnqueueImpostorError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get information about a specific Avatar.
pub async fn get_avatar(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<models::Avatar, Error<GetAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Avatar`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Avatar`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List avatar styles.
pub async fn get_avatar_styles(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::AvatarStyle>, Error<GetAvatarStylesError>> {
    let uri_str = format!("{}/avatarStyles", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AvatarStyle&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AvatarStyle&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAvatarStylesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search and list favorited avatars by query filters.
pub async fn get_favorited_avatars(
    configuration: &configuration::Configuration,
    featured: Option<bool>,
    sort: Option<models::SortOption>,
    n: Option<i32>,
    order: Option<models::OrderOption>,
    offset: Option<i32>,
    search: Option<&str>,
    tag: Option<&str>,
    notag: Option<&str>,
    release_status: Option<models::ReleaseStatus>,
    max_unity_version: Option<&str>,
    min_unity_version: Option<&str>,
    platform: Option<&str>,
    user_id: Option<&str>,
) -> Result<Vec<models::Avatar>, Error<GetFavoritedAvatarsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_featured = featured;
    let p_query_sort = sort;
    let p_query_n = n;
    let p_query_order = order;
    let p_query_offset = offset;
    let p_query_search = search;
    let p_query_tag = tag;
    let p_query_notag = notag;
    let p_query_release_status = release_status;
    let p_query_max_unity_version = max_unity_version;
    let p_query_min_unity_version = min_unity_version;
    let p_query_platform = platform;
    let p_query_user_id = user_id;

    let uri_str = format!("{}/avatars/favorites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_notag {
        req_builder = req_builder.query(&[("notag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_status {
        req_builder = req_builder.query(&[("releaseStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_unity_version {
        req_builder = req_builder.query(&[("maxUnityVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_unity_version {
        req_builder = req_builder.query(&[("minUnityVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFavoritedAvatarsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets service stats for queued impostor.
pub async fn get_impostor_queue_stats(
    configuration: &configuration::Configuration,
) -> Result<models::ServiceQueueStats, Error<GetImpostorQueueStatsError>> {
    let uri_str = format!("{}/avatars/impostor/queue/stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServiceQueueStats`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServiceQueueStats`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImpostorQueueStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List licensed avatars.
pub async fn get_licensed_avatars(
    configuration: &configuration::Configuration,
    n: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::Avatar>, Error<GetLicensedAvatarsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_n = n;
    let p_query_offset = offset;

    let uri_str = format!("{}/avatars/licensed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLicensedAvatarsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the current avatar for the user. This will return an error for any other user than the one logged in.
pub async fn get_own_avatar(
    configuration: &configuration::Configuration,
    user_id: &str,
) -> Result<models::Avatar, Error<GetOwnAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/users/{userId}/avatar",
        configuration.base_path,
        userId = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Avatar`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Avatar`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOwnAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
pub async fn search_avatars(
    configuration: &configuration::Configuration,
    featured: Option<bool>,
    sort: Option<models::SortOption>,
    user: Option<&str>,
    user_id: Option<&str>,
    n: Option<i32>,
    order: Option<models::OrderOption>,
    offset: Option<i32>,
    tag: Option<&str>,
    notag: Option<&str>,
    release_status: Option<models::ReleaseStatus>,
    max_unity_version: Option<&str>,
    min_unity_version: Option<&str>,
    platform: Option<&str>,
    is_internal_variant: Option<bool>,
) -> Result<Vec<models::Avatar>, Error<SearchAvatarsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_featured = featured;
    let p_query_sort = sort;
    let p_query_user = user;
    let p_query_user_id = user_id;
    let p_query_n = n;
    let p_query_order = order;
    let p_query_offset = offset;
    let p_query_tag = tag;
    let p_query_notag = notag;
    let p_query_release_status = release_status;
    let p_query_max_unity_version = max_unity_version;
    let p_query_min_unity_version = min_unity_version;
    let p_query_platform = platform;
    let p_query_is_internal_variant = is_internal_variant;

    let uri_str = format!("{}/avatars", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_featured {
        req_builder = req_builder.query(&[("featured", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_n {
        req_builder = req_builder.query(&[("n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_notag {
        req_builder = req_builder.query(&[("notag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_release_status {
        req_builder = req_builder.query(&[("releaseStatus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_max_unity_version {
        req_builder = req_builder.query(&[("maxUnityVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_min_unity_version {
        req_builder = req_builder.query(&[("minUnityVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_platform {
        req_builder = req_builder.query(&[("platform", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_internal_variant {
        req_builder = req_builder.query(&[("isInternalVariant", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Avatar&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchAvatarsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Switches into that avatar.
pub async fn select_avatar(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<models::CurrentUser, Error<SelectAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}/select",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CurrentUser`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CurrentUser`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelectAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Switches into that avatar as your fallback avatar.
#[deprecated]
pub async fn select_fallback_avatar(
    configuration: &configuration::Configuration,
    avatar_id: &str,
) -> Result<models::CurrentUser, Error<SelectFallbackAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;

    let uri_str = format!(
        "{}/avatars/{avatarId}/selectFallback",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CurrentUser`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CurrentUser`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SelectFallbackAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update information about a specific avatar.
pub async fn update_avatar(
    configuration: &configuration::Configuration,
    avatar_id: &str,
    update_avatar_request: Option<models::UpdateAvatarRequest>,
) -> Result<models::Avatar, Error<UpdateAvatarError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_avatar_id = avatar_id;
    let p_body_update_avatar_request = update_avatar_request;

    let uri_str = format!(
        "{}/avatars/{avatarId}",
        configuration.base_path,
        avatarId = crate::apis::urlencode(p_path_avatar_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_avatar_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Avatar`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Avatar`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAvatarError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
